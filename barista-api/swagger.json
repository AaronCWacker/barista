{
  "swagger": "2.0",
  "info": { "description": "REST API documentation for the Barista system", "version": "1.0", "title": "Barista API" },
  "basePath": "/api/v1",
  "tags": [
    { "name": "BomLicenseException", "description": "Methods" },
    { "name": "BomManualLicense", "description": "Methods" },
    { "name": "BomSecurityException", "description": "Methods" },
    { "name": "DeploymentType", "description": "Methods" },
    { "name": "License", "description": "Methods" },
    { "name": "LicenseScanResult", "description": "Methods" },
    { "name": "LicenseScanResultItem", "description": "Methods" },
    { "name": "LicenseStatusDeploymentType", "description": "Methods" },
    { "name": "Obligation", "description": "Methods" },
    { "name": "ObligationType", "description": "Methods" },
    { "name": "OutputFormatType", "description": "Methods" },
    { "name": "PackageManager", "description": "Methods" },
    { "name": "Project", "description": "Methods" },
    { "name": "ProjectDevelopmentType", "description": "Methods" },
    { "name": "ProjectStatusType", "description": "Methods" },
    { "name": "ProjectScanStatusType", "description": "Methods" },
    { "name": "Scan", "description": "Methods" },
    { "name": "SecurityScanResult", "description": "Methods" },
    { "name": "SecurityScanResultItem", "description": "Methods" },
    { "name": "SecurityScanResultItemStatusType", "description": "Methods" },
    { "name": "SystemConfiguration", "description": "Methods" },
    { "name": "ToolTip", "description": "Methods" },
    { "name": "User", "description": "Methods" },
    { "name": "VulnerabilityStatusDeploymentType", "description": "Methods" }
  ],
  "schemes": ["https", "http"],
  "securityDefinitions": {
    "bearer": { "type": "apiKey", "name": "Authorization", "in": "header" },
    "oauth2": { "type": "oauth2", "flow": "accessCode" }
  },
  "paths": {
    "/status": {
      "get": {
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/AppStatus" } } },
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-license-exception": {
      "post": {
        "parameters": [
          {
            "name": "BomLicenseException",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/BomLicenseException" }
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomLicenseException" } } },
        "tags": ["BomLicenseException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve many BomLicenseException",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomLicenseException" } }
          }
        },
        "tags": ["BomLicenseException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-license-exception/{id}": {
      "delete": {
        "summary": "Delete one BomLicenseException",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomLicenseException" } } },
        "tags": ["BomLicenseException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one BomLicenseException",
        "parameters": [
          {
            "name": "BomLicenseException",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/BomLicenseException" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomLicenseException" } } },
        "tags": ["BomLicenseException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve one BomLicenseException",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomLicenseException" } } },
        "tags": ["BomLicenseException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-license-exception/search": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "projectId", "required": true, "in": "query" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomLicenseException" } }
          }
        },
        "tags": ["BomLicenseException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-license-exception/bulk": {
      "post": {
        "summary": "Create many BomLicenseException",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomLicenseException" } }
          }
        },
        "tags": ["BomLicenseException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "undefined": {
      "undefined": {
        "summary": "Retrieve many Project",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Project" } } }
        },
        "tags": ["Stats"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-manual-license": {
      "post": {
        "parameters": [
          {
            "name": "BomManualLicense",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/BomManualLicense" }
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomManualLicense" } } },
        "tags": ["BomManualLicense"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve many BomManualLicense",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomManualLicense" } }
          }
        },
        "tags": ["BomManualLicense"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-manual-license/search": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "projectId", "required": true, "in": "query" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomManualLicense" } }
          }
        },
        "tags": ["BomManualLicense"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-manual-license/{id}": {
      "get": {
        "summary": "Retrieve one BomManualLicense",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomManualLicense" } } },
        "tags": ["BomManualLicense"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one BomManualLicense",
        "parameters": [
          {
            "name": "BomManualLicense",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/BomManualLicense" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomManualLicense" } } },
        "tags": ["BomManualLicense"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one BomManualLicense",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomManualLicense" } } },
        "tags": ["BomManualLicense"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-manual-license/bulk": {
      "post": {
        "summary": "Create many BomManualLicense",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomManualLicense" } }
          }
        },
        "tags": ["BomManualLicense"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-security-exception": {
      "post": {
        "summary": "Create one BomSecurityException",
        "parameters": [
          {
            "name": "BomSecurityException",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/BomSecurityException" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/BomSecurityException" } } },
        "tags": ["BomSecurityException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve many BomSecurityException",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomSecurityException" } }
          }
        },
        "tags": ["BomSecurityException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-security-exception/{id}": {
      "delete": {
        "summary": "Delete one BomSecurityException",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomSecurityException" } } },
        "tags": ["BomSecurityException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one BomSecurityException",
        "parameters": [
          {
            "name": "BomSecurityException",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/BomSecurityException" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomSecurityException" } } },
        "tags": ["BomSecurityException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve one BomSecurityException",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/BomSecurityException" } } },
        "tags": ["BomSecurityException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-security-exception/search": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "projectId", "required": true, "in": "query" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomSecurityException" } }
          }
        },
        "tags": ["BomSecurityException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/bom-security-exception/bulk": {
      "post": {
        "summary": "Create many BomSecurityException",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/BomSecurityException" } }
          }
        },
        "tags": ["BomSecurityException"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/deployment-type": {
      "get": {
        "summary": "Retrieve many DeploymentType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/DeploymentType" } }
          }
        },
        "tags": ["DeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one DeploymentType",
        "parameters": [
          {
            "name": "DeploymentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/DeploymentType" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/DeploymentType" } } },
        "tags": ["DeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/deployment-type/{id}": {
      "get": {
        "summary": "Retrieve one DeploymentType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/DeploymentType" } } },
        "tags": ["DeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one DeploymentType",
        "parameters": [
          {
            "name": "DeploymentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/DeploymentType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/DeploymentType" } } },
        "tags": ["DeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one DeploymentType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/DeploymentType" } } },
        "tags": ["DeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/deployment-type/bulk": {
      "post": {
        "summary": "Create many DeploymentType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/DeploymentType" } }
          }
        },
        "tags": ["DeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/global-search/search-module-1/{modulePartialName}/{page}/{pageSize}": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "path" },
          { "type": "number", "name": "page", "required": true, "in": "path" },
          { "type": "string", "name": "modulePartialName", "required": true, "in": "path" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ModuleSearchParentRecordDto" } }
          }
        },
        "tags": ["GlobalSearch"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/global-search/search-module-2/{projectId}/{modulePartialName}/{page}/{pageSize}": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "path" },
          { "type": "number", "name": "page", "required": true, "in": "path" },
          { "type": "string", "name": "modulePartialName", "required": true, "in": "path" },
          { "type": "number", "name": "projectId", "required": true, "in": "path" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ModuleSearchChildRecordDto" } }
          }
        },
        "tags": ["GlobalSearch"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license/associate-obligation-to-licences-by-filter": {
      "post": {
        "parameters": [
          {
            "name": "EntityCodeAndRelationFilterDto",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/EntityCodeAndRelationFilterDto" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license/delete-obligation-from-licences-by-filter": {
      "post": {
        "parameters": [
          {
            "name": "EntityCodeAndRelationFilterDto",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/EntityCodeAndRelationFilterDto" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license/search": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "filterText", "required": true, "in": "query" }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/License" } } }
        },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license/obligations": {
      "get": {
        "parameters": [
          { "type": "number", "name": "perPage", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "licenseCode", "required": true, "in": "query" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ObligationSearchDto" } }
          }
        },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license": {
      "get": {
        "summary": "Retrieve many License",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/License" } } }
        },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one License",
        "parameters": [
          { "name": "License", "required": true, "in": "body", "schema": { "$ref": "#/definitions/License" } }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/License" } } },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license/{id}": {
      "get": {
        "summary": "Retrieve one License",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/License" } } },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one License",
        "parameters": [
          { "name": "License", "required": true, "in": "body", "schema": { "$ref": "#/definitions/License" } },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/License" } } },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one License",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/License" } } },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license/bulk": {
      "post": {
        "summary": "Create many License",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/License" } } }
        },
        "tags": ["License"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-scan-result": {
      "get": {
        "summary": "Retrieve many LicenseScanResult",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseScanResult" } }
          }
        },
        "tags": ["LicenseScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one LicenseScanResult",
        "parameters": [
          {
            "name": "LicenseScanResult",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseScanResult" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResult" } } },
        "tags": ["LicenseScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-scan-result/{id}": {
      "get": {
        "summary": "Retrieve one LicenseScanResult",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResult" } } },
        "tags": ["LicenseScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one LicenseScanResult",
        "parameters": [
          {
            "name": "LicenseScanResult",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseScanResult" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResult" } } },
        "tags": ["LicenseScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one LicenseScanResult",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResult" } } },
        "tags": ["LicenseScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-scan-result/bulk": {
      "post": {
        "summary": "Create many LicenseScanResult",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseScanResult" } }
          }
        },
        "tags": ["LicenseScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-scan-result-item/{id}/full-details": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["LicenseScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-scan-result-item": {
      "get": {
        "summary": "Retrieve many LicenseScanResultItem",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseScanResultItem" } }
          }
        },
        "tags": ["LicenseScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one LicenseScanResultItem",
        "parameters": [
          {
            "name": "LicenseScanResultItem",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseScanResultItem" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResultItem" } } },
        "tags": ["LicenseScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-scan-result-item/{id}": {
      "get": {
        "summary": "Retrieve one LicenseScanResultItem",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResultItem" } } },
        "tags": ["LicenseScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one LicenseScanResultItem",
        "parameters": [
          {
            "name": "LicenseScanResultItem",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseScanResultItem" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResultItem" } } },
        "tags": ["LicenseScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one LicenseScanResultItem",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseScanResultItem" } } },
        "tags": ["LicenseScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-scan-result-item/bulk": {
      "post": {
        "summary": "Create many LicenseScanResultItem",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseScanResultItem" } }
          }
        },
        "tags": ["LicenseScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type/add-to-licenses": {
      "post": {
        "parameters": [
          {
            "name": "LicenseStatusDeploymentTypeUpsertDto",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseStatusDeploymentTypeUpsertDto" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type/delete": {
      "post": {
        "parameters": [
          {
            "name": "LicenseStatusDeploymentTypeUpsertDto",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseStatusDeploymentTypeUpsertDto" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type/delete-from-licenses": {
      "post": {
        "parameters": [
          {
            "name": "LicenseStatusDeploymentTypeUpsertDto",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseStatusDeploymentTypeUpsertDto" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type/get-exceptions-for-license": {
      "get": {
        "parameters": [
          { "type": "number", "name": "perPage", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "licenseCode", "required": true, "in": "query" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseStatusDeploymentType" } }
          }
        },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type/upsert": {
      "post": {
        "parameters": [
          {
            "name": "LicenseStatusDeploymentTypeUpsertDto",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseStatusDeploymentTypeUpsertDto" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type": {
      "get": {
        "summary": "Retrieve many LicenseStatusDeploymentType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseStatusDeploymentType" } }
          }
        },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one LicenseStatusDeploymentType",
        "parameters": [
          {
            "name": "LicenseStatusDeploymentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseStatusDeploymentType" }
          }
        ],
        "responses": {
          "201": { "description": "", "schema": { "$ref": "#/definitions/LicenseStatusDeploymentType" } }
        },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type/{id}": {
      "get": {
        "summary": "Retrieve one LicenseStatusDeploymentType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseStatusDeploymentType" } }
        },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one LicenseStatusDeploymentType",
        "parameters": [
          {
            "name": "LicenseStatusDeploymentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseStatusDeploymentType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseStatusDeploymentType" } }
        },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one LicenseStatusDeploymentType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/LicenseStatusDeploymentType" } }
        },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/license-status-deployment-type/bulk": {
      "post": {
        "summary": "Create many LicenseStatusDeploymentType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseStatusDeploymentType" } }
          }
        },
        "tags": ["LicenseStatusDeploymentType"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation/associate-to-license": {
      "post": {
        "parameters": [
          {
            "name": "LicenseObligation",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseObligation" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation/delete-from-license": {
      "post": {
        "parameters": [
          {
            "name": "LicenseObligation",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/LicenseObligation" }
          }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation/search": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "filterText", "required": true, "in": "query" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ObligationSearchDto" } }
          }
        },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation": {
      "get": {
        "summary": "Retrieve many Obligation",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Obligation" } } }
        },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one Obligation",
        "parameters": [
          { "name": "Obligation", "required": true, "in": "body", "schema": { "$ref": "#/definitions/Obligation" } }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/Obligation" } } },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation/{id}": {
      "get": {
        "summary": "Retrieve one Obligation",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Obligation" } } },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one Obligation",
        "parameters": [
          { "name": "Obligation", "required": true, "in": "body", "schema": { "$ref": "#/definitions/Obligation" } },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Obligation" } } },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one Obligation",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Obligation" } } },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation/bulk": {
      "post": {
        "summary": "Create many Obligation",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Obligation" } } }
        },
        "tags": ["Obligation"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation-type": {
      "get": {
        "summary": "Retrieve many ObligationType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ObligationType" } }
          }
        },
        "tags": ["ObligationType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one ObligationType",
        "parameters": [
          {
            "name": "ObligationType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ObligationType" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/ObligationType" } } },
        "tags": ["ObligationType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation-type/{id}": {
      "get": {
        "summary": "Retrieve one ObligationType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ObligationType" } } },
        "tags": ["ObligationType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one ObligationType",
        "parameters": [
          {
            "name": "ObligationType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ObligationType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ObligationType" } } },
        "tags": ["ObligationType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one ObligationType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ObligationType" } } },
        "tags": ["ObligationType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/obligation-type/bulk": {
      "post": {
        "summary": "Create many ObligationType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ObligationType" } }
          }
        },
        "tags": ["ObligationType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/output-format-type": {
      "get": {
        "summary": "Retrieve many OutputFormatType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/OutputFormatType" } }
          }
        },
        "tags": ["OutputFormatType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one OutputFormatType",
        "parameters": [
          {
            "name": "OutputFormatType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/OutputFormatType" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/OutputFormatType" } } },
        "tags": ["OutputFormatType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/output-format-type/{id}": {
      "get": {
        "summary": "Retrieve one OutputFormatType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/OutputFormatType" } } },
        "tags": ["OutputFormatType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one OutputFormatType",
        "parameters": [
          {
            "name": "OutputFormatType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/OutputFormatType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/OutputFormatType" } } },
        "tags": ["OutputFormatType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one OutputFormatType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/OutputFormatType" } } },
        "tags": ["OutputFormatType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/output-format-type/bulk": {
      "post": {
        "summary": "Create many OutputFormatType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/OutputFormatType" } }
          }
        },
        "tags": ["OutputFormatType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/package-manager": {
      "get": {
        "summary": "Retrieve many PackageManager",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/PackageManager" } }
          }
        },
        "tags": ["PackageManager"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one PackageManager",
        "parameters": [
          {
            "name": "PackageManager",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/PackageManager" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/PackageManager" } } },
        "tags": ["PackageManager"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/package-manager/{id}": {
      "get": {
        "summary": "Retrieve one PackageManager",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/PackageManager" } } },
        "tags": ["PackageManager"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one PackageManager",
        "parameters": [
          {
            "name": "PackageManager",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/PackageManager" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/PackageManager" } } },
        "tags": ["PackageManager"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one PackageManager",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/PackageManager" } } },
        "tags": ["PackageManager"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/package-manager/bulk": {
      "post": {
        "summary": "Create many PackageManager",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/PackageManager" } }
          }
        },
        "tags": ["PackageManager"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/bill-of-materials/licenses": {
      "get": {
        "parameters": [
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "id", "required": true, "in": "path" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseScanResultItem" } }
          }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/bill-of-materials/licenses-only": {
      "get": {
        "parameters": [
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "id", "required": true, "in": "path" }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseDto" } } }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/bill-of-materials/modules-from-license/{licenseId}": {
      "get": {
        "parameters": [
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "number", "name": "licenseId", "required": true, "in": "path" },
          { "type": "string", "name": "id", "required": true, "in": "path" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/LicenseModuleDto" } }
          }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/bill-of-materials/vulnerabilities": {
      "get": {
        "parameters": [
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "id", "required": true, "in": "path" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResultItem" } }
          }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project": {
      "post": {
        "parameters": [
          { "name": "Project", "required": true, "in": "body", "schema": { "$ref": "#/definitions/Project" } }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Project" } } },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve many Project",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Project" } } }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/search": {
      "get": {
        "parameters": [
          { "type": "string", "name": "developmentType", "required": true, "in": "query" },
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "string", "name": "filterText", "required": true, "in": "query" }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Project" } } }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/stats/licenses": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectDistinctLicenseDto" } }
          }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/obligations": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/stats/project-scan-status": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectScanStateDto" } } },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/stats/severities": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectDistinctSeverityDto" } }
          }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/unique-bom-obligations": {
      "get": {
        "parameters": [
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" },
          { "type": "number", "name": "id", "required": true, "in": "path" }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ObligationSearchDto" } }
          }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}": {
      "patch": {
        "summary": "Update one Project",
        "parameters": [
          { "name": "Project", "required": true, "in": "body", "schema": { "$ref": "#/definitions/Project" } },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Project" } } },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve one Project",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Project" } } },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one Project",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Project" } } },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/{id}/stats/vulnerabilities": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectDistinctVulnerabilityDto" } }
          }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project/bulk": {
      "post": {
        "summary": "Create many Project",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Project" } } }
        },
        "tags": ["Project"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-development-type": {
      "get": {
        "summary": "Retrieve many ProjectDevelopmentType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectDevelopmentType" } }
          }
        },
        "tags": ["ProjectDevelopmentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one ProjectDevelopmentType",
        "parameters": [
          {
            "name": "ProjectDevelopmentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ProjectDevelopmentType" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/ProjectDevelopmentType" } } },
        "tags": ["ProjectDevelopmentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-development-type/{id}": {
      "get": {
        "summary": "Retrieve one ProjectDevelopmentType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectDevelopmentType" } } },
        "tags": ["ProjectDevelopmentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one ProjectDevelopmentType",
        "parameters": [
          {
            "name": "ProjectDevelopmentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ProjectDevelopmentType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectDevelopmentType" } } },
        "tags": ["ProjectDevelopmentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one ProjectDevelopmentType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectDevelopmentType" } } },
        "tags": ["ProjectDevelopmentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-development-type/bulk": {
      "post": {
        "summary": "Create many ProjectDevelopmentType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectDevelopmentType" } }
          }
        },
        "tags": ["ProjectDevelopmentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-notes": {
      "post": {
        "parameters": [
          { "name": "ProjectNote", "required": true, "in": "body", "schema": { "$ref": "#/definitions/ProjectNote" } }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectNote" } } },
        "tags": ["ProjectNotes"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "get": {
        "summary": "Retrieve many ProjectNote",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectNote" } } }
        },
        "tags": ["ProjectNotes"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-notes/{id}": {
      "get": {
        "summary": "Retrieve one ProjectNote",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectNote" } } },
        "tags": ["ProjectNotes"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one ProjectNote",
        "parameters": [
          { "name": "ProjectNote", "required": true, "in": "body", "schema": { "$ref": "#/definitions/ProjectNote" } },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectNote" } } },
        "tags": ["ProjectNotes"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one ProjectNote",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectNote" } } },
        "tags": ["ProjectNotes"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-notes/bulk": {
      "post": {
        "summary": "Create many ProjectNote",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectNote" } } }
        },
        "tags": ["ProjectNotes"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-scan-status-type": {
      "get": {
        "summary": "Retrieve many ProjectScanStatusType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectScanStatusType" } }
          }
        },
        "tags": ["ProjectScanStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one ProjectScanStatusType",
        "parameters": [
          {
            "name": "ProjectScanStatusType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ProjectScanStatusType" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/ProjectScanStatusType" } } },
        "tags": ["ProjectScanStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-scan-status-type/{id}": {
      "get": {
        "summary": "Retrieve one ProjectScanStatusType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectScanStatusType" } } },
        "tags": ["ProjectScanStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one ProjectScanStatusType",
        "parameters": [
          {
            "name": "ProjectScanStatusType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ProjectScanStatusType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectScanStatusType" } } },
        "tags": ["ProjectScanStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one ProjectScanStatusType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectScanStatusType" } } },
        "tags": ["ProjectScanStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-scan-status-type/bulk": {
      "post": {
        "summary": "Create many ProjectScanStatusType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectScanStatusType" } }
          }
        },
        "tags": ["ProjectScanStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-status-type": {
      "get": {
        "summary": "Retrieve many ProjectStatusType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectStatusType" } }
          }
        },
        "tags": ["ProjectStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one ProjectStatusType",
        "parameters": [
          {
            "name": "ProjectStatusType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ProjectStatusType" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/ProjectStatusType" } } },
        "tags": ["ProjectStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-status-type/{id}": {
      "get": {
        "summary": "Retrieve one ProjectStatusType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectStatusType" } } },
        "tags": ["ProjectStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one ProjectStatusType",
        "parameters": [
          {
            "name": "ProjectStatusType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ProjectStatusType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectStatusType" } } },
        "tags": ["ProjectStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one ProjectStatusType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ProjectStatusType" } } },
        "tags": ["ProjectStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/project-status-type/bulk": {
      "post": {
        "summary": "Create many ProjectStatusType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/ProjectStatusType" } }
          }
        },
        "tags": ["ProjectStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/scan/project/{id}": {
      "post": {
        "parameters": [{ "type": "number", "name": "id", "required": true, "in": "path" }],
        "responses": { "201": { "description": "" } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/scan/project/{id}/branch/": {
      "post": {
        "parameters": [
          {
            "name": "ScanBranchDto",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/ScanBranchDto" }
          },
          { "type": "number", "name": "id", "required": true, "in": "path" }
        ],
        "responses": { "201": { "description": "" } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/scan/queue/job/{id}": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/JobInfoDto" } } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/scan/queue/job/{id}/status": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/scan": {
      "get": {
        "summary": "Retrieve many Scan",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Scan" } } }
        },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one Scan",
        "parameters": [{ "name": "Scan", "required": true, "in": "body", "schema": { "$ref": "#/definitions/Scan" } }],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/Scan" } } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/scan/{id}": {
      "get": {
        "summary": "Retrieve one Scan",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Scan" } } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one Scan",
        "parameters": [
          { "name": "Scan", "required": true, "in": "body", "schema": { "$ref": "#/definitions/Scan" } },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Scan" } } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one Scan",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/Scan" } } },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/scan/bulk": {
      "post": {
        "summary": "Create many Scan",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Scan" } } }
        },
        "tags": ["Scan"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result": {
      "get": {
        "summary": "Retrieve many SecurityScanResult",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResult" } }
          }
        },
        "tags": ["SecurityScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one SecurityScanResult",
        "parameters": [
          {
            "name": "SecurityScanResult",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/SecurityScanResult" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResult" } } },
        "tags": ["SecurityScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result/{id}": {
      "get": {
        "summary": "Retrieve one SecurityScanResult",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResult" } } },
        "tags": ["SecurityScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one SecurityScanResult",
        "parameters": [
          {
            "name": "SecurityScanResult",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/SecurityScanResult" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResult" } } },
        "tags": ["SecurityScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one SecurityScanResult",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResult" } } },
        "tags": ["SecurityScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result/bulk": {
      "post": {
        "summary": "Create many SecurityScanResult",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResult" } }
          }
        },
        "tags": ["SecurityScanResult"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result-item/{id}/full-details": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["SecurityScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result-item": {
      "get": {
        "summary": "Retrieve many SecurityScanResultItem",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResultItem" } }
          }
        },
        "tags": ["SecurityScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one SecurityScanResultItem",
        "parameters": [
          {
            "name": "SecurityScanResultItem",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/SecurityScanResultItem" }
          }
        ],
        "responses": { "201": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItem" } } },
        "tags": ["SecurityScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result-item/{id}": {
      "get": {
        "summary": "Retrieve one SecurityScanResultItem",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItem" } } },
        "tags": ["SecurityScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one SecurityScanResultItem",
        "parameters": [
          {
            "name": "SecurityScanResultItem",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/SecurityScanResultItem" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItem" } } },
        "tags": ["SecurityScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one SecurityScanResultItem",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItem" } } },
        "tags": ["SecurityScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result-item/bulk": {
      "post": {
        "summary": "Create many SecurityScanResultItem",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResultItem" } }
          }
        },
        "tags": ["SecurityScanResultItem"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result-item-status-type": {
      "get": {
        "summary": "Retrieve many SecurityScanResultItemStatusType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResultItemStatusType" } }
          }
        },
        "tags": ["SecurityScanResultItemStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one SecurityScanResultItemStatusType",
        "parameters": [
          {
            "name": "SecurityScanResultItemStatusType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/SecurityScanResultItemStatusType" }
          }
        ],
        "responses": {
          "201": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItemStatusType" } }
        },
        "tags": ["SecurityScanResultItemStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result-item-status-type/{id}": {
      "get": {
        "summary": "Retrieve one SecurityScanResultItemStatusType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItemStatusType" } }
        },
        "tags": ["SecurityScanResultItemStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one SecurityScanResultItemStatusType",
        "parameters": [
          {
            "name": "SecurityScanResultItemStatusType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/SecurityScanResultItemStatusType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItemStatusType" } }
        },
        "tags": ["SecurityScanResultItemStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one SecurityScanResultItemStatusType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/SecurityScanResultItemStatusType" } }
        },
        "tags": ["SecurityScanResultItemStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/security-scan-result-item-status-type/bulk": {
      "post": {
        "summary": "Create many SecurityScanResultItemStatusType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResultItemStatusType" } }
          }
        },
        "tags": ["SecurityScanResultItemStatusType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/stats": {
      "get": {
        "summary": "Retrieve many Project",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Project" } } }
        },
        "tags": ["Stats"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/stats/badges/{id}/licensestate": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["Stats"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/stats/badges/{id}/securitystate": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["Stats"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/stats/badges/{id}/vulnerabilities": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["Stats"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/stats/badges/{id}/components": {
      "get": {
        "parameters": [{ "type": "string", "name": "id", "required": true, "in": "path" }],
        "responses": { "200": { "description": "" } },
        "tags": ["Stats"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/system-configuration": {
      "get": {
        "summary": "Retrieve many SystemConfiguration",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SystemConfiguration" } }
          }
        },
        "tags": ["SystemConfiguration"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/system-configuration/{id}": {
      "get": {
        "summary": "Retrieve one SystemConfiguration",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "string" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SystemConfiguration" } } },
        "tags": ["SystemConfiguration"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one SystemConfiguration",
        "parameters": [
          {
            "name": "SystemConfiguration",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/SystemConfiguration" }
          },
          { "name": "id", "required": true, "in": "path", "type": "string" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/SystemConfiguration" } } },
        "tags": ["SystemConfiguration"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/system-configuration/bulk": {
      "post": {
        "summary": "Create many SystemConfiguration",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/SystemConfiguration" } }
          }
        },
        "tags": ["SystemConfiguration"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/tooltip": {
      "get": {
        "summary": "Retrieve many ToolTip",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/ToolTip" } } }
        },
        "tags": ["ToolTip"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/tooltip/{id}": {
      "get": {
        "summary": "Retrieve one ToolTip",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ToolTip" } } },
        "tags": ["ToolTip"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one ToolTip",
        "parameters": [
          { "name": "ToolTip", "required": true, "in": "body", "schema": { "$ref": "#/definitions/ToolTip" } },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/ToolTip" } } },
        "tags": ["ToolTip"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/user/projects": {
      "get": {
        "parameters": [
          { "type": "string", "name": "filterText", "required": true, "in": "query" },
          { "type": "number", "name": "pageSize", "required": true, "in": "query" },
          { "type": "number", "name": "page", "required": true, "in": "query" }
        ],
        "responses": {
          "200": { "description": "", "schema": { "type": "array", "items": { "$ref": "#/definitions/Project" } } }
        },
        "tags": ["User"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/user/me": {
      "get": {
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/UserInfo" } } },
        "tags": ["User"],
        "security": [{ "oauth2": [] }],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/user/login": {
      "post": {
        "parameters": [
          { "name": "LoginDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/LoginDto" } }
        ],
        "responses": { "200": { "description": "", "schema": { "$ref": "#/definitions/AuthJwtToken" } } },
        "tags": ["User"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/vulnerability-status-deployment-type": {
      "get": {
        "summary": "Retrieve many VulnerabilityStatusDeploymentType",
        "parameters": [
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "filter[]",
            "description": "<h4>Adds fields request condition (multiple conditions) to the request.</h4><i>Syntax:</i> <strong>?filter[]=field||condition||value</strong><br/><i>Examples:</i> <ul><li><strong>?filter[]=name||eq||batman</strong></li><li><strong>?filter[]=isVillain||eq||false&filter[]=city||eq||Arkham</strong> (multiple filters are treated as a combination of AND type of conditions)</li><li><strong>?filter[]=shots||in||12,26</strong> (some conditions accept multiple values separated by commas)</li><li><strong>?filter[]=power||isnull</strong> (some conditions don't accept value)</li></ul><br/>Filter Conditions:<ul><li><strong><code>eq</code></strong> (<code>=</code>, equal)</li><li><strong><code>ne</code></strong> (<code>!=</code>, not equal)</li><li><strong><code>gt</code></strong> (<code>&gt;</code>, greater than)</li><li><strong><code>lt</code></strong> (<code>&lt;</code>, lower that)</li><li><strong><code>gte</code></strong> (<code>&gt;=</code>, greater than or equal)</li><li><strong><code>lte</code></strong> (<code>&lt;=</code>, lower than or equal)</li><li><strong><code>starts</code></strong> (<code>LIKE val%</code>, starts with)</li><li><strong><code>ends</code></strong> (<code>LIKE %val</code>, ends with)</li><li><strong><code>cont</code></strong> (<code>LIKE %val%</code>, contains)</li><li><strong><code>excl</code></strong> (<code>NOT LIKE %val%</code>, not contains)</li><li><strong><code>in</code></strong> (<code>IN</code>, in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>notin</code></strong> (<code>NOT IN</code>, not in range, <strong><em>accepts multiple values</em></strong>)</li><li><strong><code>isnull</code></strong> (<code>IS NULL</code>, is NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>notnull</code></strong> (<code>IS NOT NULL</code>, not NULL, <strong><em>doesn't accept value</em></strong>)</li><li><strong><code>between</code></strong> (<code>BETWEEN</code>, between, <strong><em>accepts two values</em></strong>)</li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "or[]",
            "description": "<h4>Adds <code>OR</code> conditions to the request.</h4><i>Syntax:</i> <strong>?or[]=field||condition||value</strong><br/>It uses the same conditions as the filter parameter<br/><i>Rules and <i>Examples:</i></i><ul><li>If there is only <strong>one</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as simple filter:</li><ul><li><strong>?or[]=name||eq||batman</strong></li></ul></ul><ul><li>If there are <strong>multiple</strong> <code>or</code> present (without <code>filter</code>) then it will be interpreted as a compination of <code>OR</code> conditions, as follows:<br><code>WHERE {or} OR {or} OR ...</code></li><ul><li><strong>?or[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If there are <strong>one</strong> <code>or</code> and <strong>one</strong> <code>filter</code> then it will be interpreted as <code>OR</code> condition, as follows:<br><code>WHERE {filter} OR {or}</code></li><ul><li><strong>?filter[]=name||eq||batman&or[]=name||eq||joker</strong></li></ul></ul><ul><li>If present <strong>both</strong> <code>or</code> and <code>filter</code> in any amount (<strong>one</strong> or <strong>miltiple</strong> each) then both interpreted as a combitation of <code>AND</code> conditions and compared with each other by <code>OR</code> condition, as follows:<br><code>WHERE ({filter} AND {filter} AND ...) OR ({or} AND {or} AND ...)</code></li><ul><li><strong>?filter[]=type||eq||hero&filter[]=status||eq||alive&or[]=type||eq||villain&or[]=status||eq||dead</strong></li></ul></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "sort[]",
            "description": "<h4>Adds sort by field (by multiple fields) and order to query result.</h4><i>Syntax:</i> <strong>?sort[]=field,ASC|DESC</strong><br/><i>Examples:</i></i><ul><li><strong>?sort[]=name,ASC</strong></li><li><strong>?sort[]=name,ASC&sort[]=id,DESC</strong></li></ul>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "per_page",
            "description": "<h4>Receive <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?per_page=number</strong><br/><i>Example:</i> <strong>?per_page=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "offset",
            "description": "<h4>Offset <code>N</code> amount of entities.</h4><i>Syntax:</i> <strong>?offset=number</strong><br/><i>Example:</i> <strong>?offset=10</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "page",
            "description": "<h4>Receive a portion of <code>limit</code> entities (alternative to <code>offset</code>). Will be applied if <code>limit</code> is set up.</h4><i>Syntax:</i> <strong>?page=number</strong><br/><i>Example:</i> <strong>?page=2</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" } }
          }
        },
        "tags": ["VulnerabilityStatusDeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "post": {
        "summary": "Create one VulnerabilityStatusDeploymentType",
        "parameters": [
          {
            "name": "VulnerabilityStatusDeploymentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" }
          }
        ],
        "responses": {
          "201": { "description": "", "schema": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" } }
        },
        "tags": ["VulnerabilityStatusDeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/vulnerability-status-deployment-type/{id}": {
      "get": {
        "summary": "Retrieve one VulnerabilityStatusDeploymentType",
        "parameters": [
          { "name": "id", "required": true, "in": "path", "type": "number" },
          {
            "name": "fields",
            "description": "<h4>Selects fields that should be returned in the reponse body.</h4><i>Syntax:</i> <strong>?fields=field1,field2,...</strong> <br/><i>Example:</i> <strong>?fields=email,name</strong>",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "join[]",
            "description": "<h4>Receive joined relational objects in GET result (with all or selected fields).</h4><i>Syntax:</i><ul><li><strong>?join[]=relation</strong></li><li><strong>?join[]=relation||field1,field2,...</strong></li><li><strong>?join[]=relation1||field11,field12,...&join[]=relation1.nested||field21,field22,...&join[]=...</strong></li></ul><br/><i>Examples:</i></i><ul><li><strong>?join[]=profile</strong></li><li><strong>?join[]=profile||firstName,email</strong></li><li><strong>?join[]=profile||firstName,email&join[]=notifications||content&join[]=tasks</strong></li><li><strong>?join[]=relation1&join[]=relation1.nested&join[]=relation1.nested.deepnested</strong></li></ul><strong><i>Notice:</i></strong> <code>id</code> field always persists in relational objects. To use nested relations, the parent level MUST be set before the child level like example above.",
            "required": false,
            "in": "query",
            "type": "string"
          },
          {
            "name": "cache",
            "description": "<h4>Reset cache (if was enabled) and receive entities from the DB.</h4><i>Usage:</i> <strong>?cache=0</strong>",
            "required": false,
            "in": "query",
            "type": "number"
          }
        ],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" } }
        },
        "tags": ["VulnerabilityStatusDeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "patch": {
        "summary": "Update one VulnerabilityStatusDeploymentType",
        "parameters": [
          {
            "name": "VulnerabilityStatusDeploymentType",
            "required": true,
            "in": "body",
            "schema": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" }
          },
          { "name": "id", "required": true, "in": "path", "type": "number" }
        ],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" } }
        },
        "tags": ["VulnerabilityStatusDeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      },
      "delete": {
        "summary": "Delete one VulnerabilityStatusDeploymentType",
        "parameters": [{ "name": "id", "required": true, "in": "path", "type": "number" }],
        "responses": {
          "200": { "description": "", "schema": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" } }
        },
        "tags": ["VulnerabilityStatusDeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    },
    "/vulnerability-status-deployment-type/bulk": {
      "post": {
        "summary": "Create many VulnerabilityStatusDeploymentType",
        "parameters": [
          { "name": "BulkDto", "required": true, "in": "body", "schema": { "$ref": "#/definitions/BulkDto" } }
        ],
        "responses": {
          "201": {
            "description": "",
            "schema": { "type": "array", "items": { "$ref": "#/definitions/VulnerabilityStatusDeploymentType" } }
          }
        },
        "tags": ["VulnerabilityStatusDeploymentType"],
        "produces": ["application/json"],
        "consumes": ["application/json"]
      }
    }
  },
  "definitions": {
    "AppStatus": {
      "type": "object",
      "properties": {
        "appCommitHash": { "type": "string" },
        "appEnvironment": { "type": "string" },
        "appMetaData": { "type": "object" },
        "appName": { "type": "string" },
        "appVersion": { "type": "string" },
        "nodeEnv": { "type": "string" }
      },
      "required": ["appCommitHash", "appEnvironment", "appMetaData", "appName", "appVersion", "nodeEnv"]
    },
    "Date": { "type": "object", "properties": {} },
    "JobInfoDto": {
      "type": "object",
      "properties": {
        "attemptsMade": { "type": "number" },
        "data": { "type": "object" },
        "delay": { "type": "number" },
        "finishedOn": { "type": "object" },
        "id": { "type": "number" },
        "name": { "type": "string" },
        "opts": { "type": "object" },
        "processedOn": { "type": "object" },
        "progress": { "type": "number" },
        "returnvalue": { "type": "object" },
        "stacktrace": { "type": "array", "items": { "type": "string" } },
        "timestamp": { "type": "number" }
      },
      "required": [
        "attemptsMade",
        "data",
        "delay",
        "finishedOn",
        "id",
        "name",
        "opts",
        "processedOn",
        "progress",
        "returnvalue",
        "stacktrace",
        "timestamp"
      ]
    },
    "DeploymentType": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "ProjectDevelopmentType": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "ProjectScanStatusType": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "BomLicenseException": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "notes": { "type": "string" },
        "userId": { "type": "string" },
        "license": { "$ref": "#/definitions/License" },
        "licenseItemPath": { "type": "string" },
        "project": { "$ref": "#/definitions/Project" },
        "projectScanStatus": { "$ref": "#/definitions/ProjectScanStatusType" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "notes",
        "userId",
        "license",
        "licenseItemPath",
        "project",
        "projectScanStatus"
      ]
    },
    "BomManualLicense": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "notes": { "type": "string" },
        "userId": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "license": { "$ref": "#/definitions/License" },
        "productName": { "type": "string" },
        "productVersion": { "type": "string" },
        "project": { "$ref": "#/definitions/Project" },
        "projectScanStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "referenceUrl": { "type": "string" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "notes",
        "userId",
        "isDefault",
        "license",
        "productName",
        "productVersion",
        "project",
        "projectScanStatus",
        "referenceUrl"
      ]
    },
    "OutputFormatType": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "PackageManager": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "ProjectNote": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "note": { "type": "string" },
        "notePayload": { "type": "string" },
        "project": { "$ref": "#/definitions/Project" },
        "userId": { "type": "string" }
      },
      "required": ["createdAt", "id", "metaData", "tag", "updatedAt", "note", "notePayload", "project", "userId"]
    },
    "ProjectStatusType": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "BomSecurityException": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "notes": { "type": "string" },
        "userId": { "type": "string" },
        "cveId": { "type": "string" },
        "project": { "$ref": "#/definitions/Project" },
        "projectScanStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "securityItemPath": { "type": "string" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "notes",
        "userId",
        "cveId",
        "project",
        "projectScanStatus",
        "securityItemPath"
      ]
    },
    "Project": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "askID": { "type": "string" },
        "configuration": { "type": "string" },
        "currentVersion": { "type": "string" },
        "customPackageManagerFilename": { "type": "string" },
        "customPackageManagerPath": { "type": "string" },
        "deploymentType": { "$ref": "#/definitions/DeploymentType" },
        "description": { "type": "string" },
        "developmentType": { "$ref": "#/definitions/ProjectDevelopmentType" },
        "gitUrl": { "type": "string" },
        "globalLicenseException": { "type": "boolean" },
        "globalSecurityException": { "type": "boolean" },
        "importMetaData": { "type": "object" },
        "LatestLicenseStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "LatestSecurityStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "licenseExceptions": { "type": "array", "items": { "$ref": "#/definitions/BomLicenseException" } },
        "manualLicenses": { "type": "array", "items": { "$ref": "#/definitions/BomManualLicense" } },
        "name": { "type": "string" },
        "outputEmail": { "type": "string" },
        "outputFormat": { "$ref": "#/definitions/OutputFormatType" },
        "owner": { "type": "string" },
        "packageManager": { "$ref": "#/definitions/PackageManager" },
        "pathToUploadFileForScanning": { "type": "string" },
        "projectNotes": { "type": "array", "items": { "$ref": "#/definitions/ProjectNote" } },
        "projectStatus": { "$ref": "#/definitions/ProjectStatusType" },
        "scans": { "type": "array", "items": { "$ref": "#/definitions/Scan" } },
        "securityExceptions": { "type": "array", "items": { "$ref": "#/definitions/BomSecurityException" } },
        "userId": { "type": "string" },
        "wasImported": { "type": "boolean" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "askID",
        "configuration",
        "currentVersion",
        "customPackageManagerFilename",
        "customPackageManagerPath",
        "deploymentType",
        "description",
        "developmentType",
        "gitUrl",
        "globalLicenseException",
        "globalSecurityException",
        "importMetaData",
        "LatestLicenseStatus",
        "LatestSecurityStatus",
        "licenseExceptions",
        "manualLicenses",
        "name",
        "outputEmail",
        "outputFormat",
        "owner",
        "packageManager",
        "pathToUploadFileForScanning",
        "projectNotes",
        "projectStatus",
        "scans",
        "securityExceptions",
        "userId",
        "wasImported"
      ]
    },
    "SecurityScanResult": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "completedAt": { "$ref": "#/definitions/Date" },
        "htmlResults": { "type": "string" },
        "jsonResults": { "type": "object" },
        "scan": { "$ref": "#/definitions/Scan" },
        "scanTool": { "type": "string" },
        "startedAt": { "$ref": "#/definitions/Date" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "completedAt",
        "htmlResults",
        "jsonResults",
        "scan",
        "scanTool",
        "startedAt"
      ]
    },
    "Scan": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "completedAt": { "$ref": "#/definitions/Date" },
        "jobInfo": { "$ref": "#/definitions/JobInfoDto" },
        "licenseScanResults": { "type": "array", "items": { "$ref": "#/definitions/LicenseScanResult" } },
        "project": { "$ref": "#/definitions/Project" },
        "securityScanResults": { "type": "array", "items": { "$ref": "#/definitions/SecurityScanResult" } },
        "startedAt": { "$ref": "#/definitions/Date" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "completedAt",
        "jobInfo",
        "licenseScanResults",
        "project",
        "securityScanResults",
        "startedAt"
      ]
    },
    "LicenseScanResult": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "completedAt": { "$ref": "#/definitions/Date" },
        "scan": { "$ref": "#/definitions/Scan" },
        "scanTool": { "type": "string" },
        "startedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["createdAt", "id", "metaData", "tag", "updatedAt", "completedAt", "scan", "scanTool", "startedAt"]
    },
    "LicenseScanResultItem": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "displayIdentifier": { "type": "string" },
        "itemType": { "type": "string" },
        "path": { "type": "string" },
        "fuzzyMatched": { "type": "boolean" },
        "license": { "$ref": "#/definitions/License" },
        "licenseScan": { "$ref": "#/definitions/LicenseScanResult" },
        "projectScanStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "publisherEmail": { "type": "string" },
        "publisherName": { "type": "string" },
        "publisherUrl": { "type": "string" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "description",
        "displayIdentifier",
        "itemType",
        "path",
        "fuzzyMatched",
        "license",
        "licenseScan",
        "projectScanStatus",
        "publisherEmail",
        "publisherName",
        "publisherUrl"
      ]
    },
    "Obligation": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "code": { "type": "string" },
        "desc": { "type": "string" },
        "licenses": { "type": "array", "items": { "$ref": "#/definitions/License" } },
        "name": { "type": "string" }
      },
      "required": ["createdAt", "id", "metaData", "tag", "updatedAt", "code", "desc", "licenses", "name"]
    },
    "License": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "code": { "type": "string" },
        "desc": { "type": "string" },
        "homepageUrl": { "type": "string" },
        "isCpdx": { "type": "boolean" },
        "licenseScanResultItems": { "type": "array", "items": { "$ref": "#/definitions/LicenseScanResultItem" } },
        "name": { "type": "string" },
        "obligations": { "type": "array", "items": { "$ref": "#/definitions/Obligation" } },
        "referenceUrl": { "type": "string" },
        "textUrl": { "type": "string" },
        "unknownLicense": { "type": "boolean" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "code",
        "desc",
        "homepageUrl",
        "isCpdx",
        "licenseScanResultItems",
        "name",
        "obligations",
        "referenceUrl",
        "textUrl",
        "unknownLicense"
      ]
    },
    "BulkDto": { "type": "object", "properties": {} },
    "ModuleSearchParentRecordDto": {
      "type": "object",
      "properties": {
        "entityCount": { "type": "number" },
        "entityName": { "type": "string" },
        "projectDescription": { "type": "string" },
        "projectEmail": { "type": "string" },
        "projectGitUrl": { "type": "string" },
        "projectId": { "type": "number" },
        "projectName": { "type": "string" },
        "projectOwner": { "type": "string" }
      },
      "required": [
        "entityCount",
        "entityName",
        "projectDescription",
        "projectEmail",
        "projectGitUrl",
        "projectId",
        "projectName",
        "projectOwner"
      ]
    },
    "ModuleSearchChildRecordDto": {
      "type": "object",
      "properties": {
        "entityCreationDate": { "$ref": "#/definitions/Date" },
        "entityName": { "type": "string" },
        "projectId": { "type": "number" }
      },
      "required": ["entityCreationDate", "entityName", "projectId"]
    },
    "EntityCodeAndRelationFilterDto": {
      "type": "object",
      "properties": { "code": { "type": "string" }, "filter": { "type": "string" } },
      "required": ["code", "filter"]
    },
    "ObligationSearchDto": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "desc": { "type": "string" },
        "id": { "type": "number" },
        "name": { "type": "string" }
      },
      "required": ["code", "desc", "id", "name"]
    },
    "LicenseStatusDeploymentTypeUpsertDto": {
      "type": "object",
      "properties": {
        "deploymentTypeCode": { "type": "string" },
        "licenseCode": { "type": "string" },
        "licenseFilter": { "type": "string" },
        "scanStatusCode": { "type": "string" }
      },
      "required": ["deploymentTypeCode", "licenseCode", "licenseFilter", "scanStatusCode"]
    },
    "LicenseStatusDeploymentType": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "deploymentType": { "$ref": "#/definitions/DeploymentType" },
        "license": { "$ref": "#/definitions/License" },
        "projectScanStatus": { "$ref": "#/definitions/ProjectScanStatusType" }
      },
      "required": ["createdAt", "id", "metaData", "tag", "updatedAt", "deploymentType", "license", "projectScanStatus"]
    },
    "LicenseObligation": {
      "type": "object",
      "properties": { "licenseCode": { "type": "string" }, "obligationCode": { "type": "string" } },
      "required": ["licenseCode", "obligationCode"]
    },
    "ObligationType": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "LicenseDto": {
      "type": "object",
      "properties": { "id": { "type": "number" }, "modulesCount": { "type": "number" }, "name": { "type": "string" } },
      "required": ["id", "modulesCount", "name"]
    },
    "LicenseModuleDto": {
      "type": "object",
      "properties": {
        "licenseScanResultItemId": { "type": "number" },
        "modulePath": { "type": "string" },
        "publisherEmail": { "type": "string" },
        "publisherName": { "type": "string" },
        "publisherUrl": { "type": "string" },
        "scanCode": { "type": "string" }
      },
      "required": [
        "licenseScanResultItemId",
        "modulePath",
        "publisherEmail",
        "publisherName",
        "publisherUrl",
        "scanCode"
      ]
    },
    "SecurityScanResultItemStatusType": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" }
      },
      "required": ["code", "createdAt", "description", "isDefault", "metaData", "sortOrder", "updatedAt"]
    },
    "SecurityScanResultItem": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "displayIdentifier": { "type": "string" },
        "itemType": { "type": "string" },
        "path": { "type": "string" },
        "cveId": { "type": "string" },
        "projectScanStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "referenceUrl": { "type": "string" },
        "securityScan": { "$ref": "#/definitions/SecurityScanResult" },
        "securityScanResultItemStatus": { "$ref": "#/definitions/SecurityScanResultItemStatusType" },
        "severity": { "type": "string" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "description",
        "displayIdentifier",
        "itemType",
        "path",
        "cveId",
        "projectScanStatus",
        "referenceUrl",
        "securityScan",
        "securityScanResultItemStatus",
        "severity"
      ]
    },
    "ProjectDistinctLicenseDto": {
      "type": "object",
      "properties": { "count": { "type": "number" }, "license": { "type": "object" } },
      "required": ["count", "license"]
    },
    "ProjectScanStateDto": {
      "type": "object",
      "properties": {
        "licenseStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "projectId": { "type": "number" },
        "securityStatus": { "$ref": "#/definitions/ProjectScanStatusType" }
      },
      "required": ["licenseStatus", "projectId", "securityStatus"]
    },
    "ProjectDistinctSeverityDto": {
      "type": "object",
      "properties": { "count": { "type": "number" }, "severity": { "type": "string" } },
      "required": ["count", "severity"]
    },
    "ProjectDistinctVulnerabilityDto": {
      "type": "object",
      "properties": { "count": { "type": "number" }, "path": { "type": "string" } },
      "required": ["count", "path"]
    },
    "ScanBranchDto": { "type": "object", "properties": { "branch": { "type": "string" } }, "required": ["branch"] },
    "SystemConfiguration": {
      "type": "object",
      "properties": {
        "code": { "type": "string" },
        "createdAt": { "$ref": "#/definitions/Date" },
        "description": { "type": "string" },
        "isDefault": { "type": "boolean" },
        "metaData": { "type": "object" },
        "sortOrder": { "type": "number" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "aboutMenu": { "type": "object" },
        "aboutPageContent": { "type": "string" },
        "askIdDisplayName": { "type": "string" },
        "contactMenu": { "type": "object" },
        "emailFromAddress": { "type": "string" },
        "githubComPasswordEnvVar": { "type": "string" },
        "githubComUsernameEnvVar": { "type": "string" },
        "githubEnterprisePasswordEnvVar": { "type": "string" },
        "githubEnterpriseUrlEnvVar": { "type": "string" },
        "githubEnterpriseUsernameEnvVar": { "type": "string" },
        "helpMenu": { "type": "object" },
        "maxProcesses": { "type": "number" },
        "npmCacheDirectory": { "type": "string" },
        "npmRegistry": { "type": "string" },
        "productionDeployUrl": { "type": "string" },
        "spdxLicenseListVersion": { "type": "string" }
      },
      "required": [
        "code",
        "createdAt",
        "description",
        "isDefault",
        "metaData",
        "sortOrder",
        "updatedAt",
        "aboutMenu",
        "aboutPageContent",
        "askIdDisplayName",
        "contactMenu",
        "emailFromAddress",
        "githubComPasswordEnvVar",
        "githubComUsernameEnvVar",
        "githubEnterprisePasswordEnvVar",
        "githubEnterpriseUrlEnvVar",
        "githubEnterpriseUsernameEnvVar",
        "helpMenu",
        "maxProcesses",
        "npmCacheDirectory",
        "npmRegistry",
        "productionDeployUrl",
        "spdxLicenseListVersion"
      ]
    },
    "ToolTip": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "content": { "type": "string" },
        "elementName": { "type": "string" },
        "enabled": { "type": "boolean" },
        "pageName": { "type": "string" }
      },
      "required": ["createdAt", "id", "metaData", "tag", "updatedAt", "content", "elementName", "enabled", "pageName"]
    },
    "UserInfo": {
      "type": "object",
      "properties": {
        "displayName": { "type": "string" },
        "email": { "type": "string" },
        "groups": { "type": "array", "items": { "type": "string" } },
        "id": { "type": "string" },
        "role": { "type": "string", "enum": ["Admin", "Collaborator", "LicenseAdmin", "SecurityAdmin"] },
        "userName": { "type": "string" }
      },
      "required": ["displayName", "email", "groups", "id", "role", "userName"]
    },
    "LoginDto": {
      "type": "object",
      "properties": { "password": { "type": "string" }, "username": { "type": "string" } },
      "required": ["password", "username"]
    },
    "AuthJwtToken": {
      "type": "object",
      "properties": { "accessToken": { "type": "string" } },
      "required": ["accessToken"]
    },
    "VulnerabilityStatusDeploymentType": {
      "type": "object",
      "properties": {
        "createdAt": { "$ref": "#/definitions/Date" },
        "id": { "type": "number" },
        "metaData": { "type": "object" },
        "tag": { "type": "string" },
        "updatedAt": { "$ref": "#/definitions/Date" },
        "deploymentType": { "$ref": "#/definitions/DeploymentType" },
        "projectScanStatus": { "$ref": "#/definitions/ProjectScanStatusType" },
        "securityStatus": { "$ref": "#/definitions/SecurityScanResultItemStatusType" }
      },
      "required": [
        "createdAt",
        "id",
        "metaData",
        "tag",
        "updatedAt",
        "deploymentType",
        "projectScanStatus",
        "securityStatus"
      ]
    }
  }
}
